= CAN_CO - The CAN Corruption device
Papp, Balazs <balazs.papp@g-epito.hu>
v1.0, 2024-04-13
:toc:
:imagesdir: images
:sectlinks:

== Introduction

Generated by {backend}

=== What CAN_CO is?

CAN_CO is a programmable device, which capable to corrupt CAN communication frames, thus enables testing systems in the presence of communication errors.

CAN_CO is a low cost device. The employed hardware provide limited operational capabilities.

Frames corrupted on mostly statistical basis, full deterministic operation can not be guaranteed.

=== What CAN_CO isn't?

NOTE: CAN_CO isn't a full blown failure generator system.

IMPORTANT: CAN_CO is a **non**deterministic failure generator.

=== Hardware architecture

=== Software architecture

=== Operating modes

. Timed corruption

	Failure pulses generated on predetermied time intervals.    
	No guarranty of frame corruption, as the failure pulse doesn't necessarily fall into a communication frame.    
	To generate meaningful corruption rate, one must consider the transmission speed: both data rate and frame rate.    
	It is also necessary to consider the required level of failure tolerance.

	Example: at 500 KBPS, 8 byte frame takes ~ 100 bits, thus ~ 200 us
	20 ms failure interval corresponds to 1 % corruption rate (supposing the distribution of the frames is uniform over the time)
	
. Counted corruption

	CAN_CO detect the start of the CAN frames (SOF). It will corrupt predetermined amount of frames. The frame corruption rate is set by the number of frames between corrupted frames.    
	It is also possible to set random amount of frame corruptions.    

	To generate meaningful corruption rate, one must consider the required level of failure tolerance.

	As SOF is detected, it is possible to generate failure pulse either during arbitration phase or during data phase.    

	Example: Setting skip frames to 99 provide 1% corruption rate.

. Triggered corruption

	The most deterministoc failure generation mode.   
	In this mode it is possible to set trigger frame, number and spacing of frame corruptions.    

	Important:

	Trigger frame can not, and will not be corrupted!    
	Trigger frame just starts failure generation. Failure generation is both number and rate limited.

== Setting up hardware

Connect CAN_CO to the CAN bus via the CAN lines, to the PC via [yellow-background]#USB#.

image::can-connection.jpg[CAN Connection]

== Setting up CAN_CO operation

CAN_CO has serial user interface. +
Communication speed is `115.200 B` +
User commands must be typed in < 100 ms. +

[lime-background]#It is highly recommended to use buffered terminal client (eg. as Arduino:Serial Monitor)#

[lime-background]#Invalid command will print the actual settings#

=== Valid commands are 

*Set up Counted Corruption* +
* N <nmin> [<nmax>]

The number of skip frames are selected from the [<nmin>:<nmax>] range, or exacctly <nmin> if no <nmax> set. +
[yellow-background]#Missing or invalid <nmin> disable Counted Corruption.#

*Set up Timed Corruption* +
* T <rate_ms>

The interval between disturbance pulses are <rate_ms> +
[yellow-background]#<rate_ms> has to be > 10 ms# +
[yellow-background]#Missing or invalid <rate_ms> disable Timed Corruption.#

*Set up Pattern Triggered Corruption* +
* P <adr> <dta>

The frame having <adr> as address and <dta> as data will start frame corruption. +
[yellow-background]#Works only with standard CAN ID# +
[yellow-background]#<dta> is handled as 16 bit integer. Matched against the first 2 bytes of the frame data in LSB first fashion.# +
[yellow-background]#<dta> = 0 is wildcard. This pattern check only the CAN ID.# +

== Considerations for operation

The three failure generation modes run in paralell. +
If both Counted and Timed corruption set up, failure is generated for both modes.

During the operation a **Status Message** is displayed after each failure generation. +
`Total failures so far N/P/T: 0/0/9` +
Where the three numbers represent the number of the Counted, Timed and Pattern induced failures respectively.

== Best practices

[lime-background]#On one hand, stochastic tests are **not reproducible**. The failure events has to be logged to allow analyzis. +
On the other hand, stochastic tests **may reveal bugs that can escape deterministic tests.**#

As failure generation with CAN_CO is a stochastik process, it is recommended to design continous tests, which are run until the required level of confidence has been reached.

It is recommended to record CAN communication during the whole test session, as it will help identify failures - if any.

The amount of log files may be reduced, if test session is split to segments, and only segment(s) containing application failures are preserved. +
In this case it is necessary to record the duration of the test session to calculate confidence level.

Patterned failure generation is a great way to stress certain periods of application's operation. +
For example if there are suspicion of failure during application parameter setting, it is recommended to align failure generation with application parameter settings.

Try to increase failure rate until application malfunction occurs. +
While overstressing the system is meaningless, the level of failure tolerance is an important metric of system operation. +
Failure tolerance is a valuable metrics for regression tests between application versions.

Take in consideration, that failure tolerance is effected by several parameters!
